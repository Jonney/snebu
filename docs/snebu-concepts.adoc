== General Concepts

=== Components

The Snebu backup system consists of a backend process `snebu`, which maintains a backup catalog in an SQLite database `snebu-catalog.db` in the directory specified in the `/etc/snebu.conf` file.  This database has a number of tables, containing entries for each host that is backed up, along with the backup sets, all file metadata, and backup set details which relate the contents of a given backup set snapshot to to files in the file details table.  Individual file contents are compressed and a file hash is computed.  The files are stored in file names reflecting the file hash in the vault directory (again as specified in the config file).  Storing files named by the hash of the file contents leads directly to file-level deduplication across directories and hosts.

When initiating a backup, a file manifest of the system to be backed up is sent to `snebu` -- this manifest consists of a list of file names and all associated metadata (ownership, permissions, size, modification times, etc).  This represents a complete snapshot of backed up file set.  This manifest gets processed to determine which files are already on the backup server.  The names of new and modified files (as determined by changes in _any_ of the metadata fields) are returned to the client, which is then passed to the `tar` command to process and create a backup.

The output of `tar` is then ingested by the `snebu` backend process, which extracts the file names and meta data, then compresses the contents of each file to a temporary staging file in the `vault` location.  After computing a sha1 hash of the file, the file is renamed to this hash and placed in the target location in the vault.

The `snebu-client` program acts as a front end to `snebu`.  Technically it isn't necessary, however you would need to generate the manifest manually (using `find` and a specific list of `-printf` specifiers -- consult the man page `snebu-newbackup(1)` for details), and send it into `snebu --newbackup`, capture the return manifest to use to generate a `tar` file, and finally sending that into `snebu --submitfiles`.

Note, that some subcommands share the same name between `snebu` and `snebu-client`.  In some cases, such as `listbackups`, there is a bit more front-end processing provided by `snebu-client`.  In other cases, such as `restore`, the actions are different.  `snebu restore` synthesizes a `tar` file on standard output, whereas `snebu-client restore` executes `snebu restore` and calls the local `tar` command to extract the files.

=== Encryption

Since `snebu` uses `tar` as a serialization format for the backup data, the `tarcrypt` command was created to act as a filter in a `tar` pipeline in order to add encryption capabilities.  The key used by `tarcrypt` contains an RSA Public key which is used to encrypt a random session key for each file.  It also contains a secret HMAC key used to "sign" each file in the backup with a deterministic hash.  The HMAC key is computed using a combination of the RSA Public key and the passphrase used to protect the RSA Private key.  That way it can not only be reliably regenerated during a restore operation (since the user needs to input the same passphrase to decrypt the backup), but it is also directly tied to the combination of the RSA keys and passphrase.  Since the HMAC key is considered sensitive, the `.key` file should be stored with appropriate restricted ownership and permissions to prevent an attacker from forging backup file contents (although a compromised HMAC key still won't permit an attacker from decrypting a backup).

Since the backup server can't know the hash of the raw file, and since a random session key is used when encrypting, that means that the has of the received file can't be utilized for deduplication purposes.  However since the HMAC signature is deterministic, this signature is utilized for deduplication purposes which works to deduplicate across any hosts that share the same key file(s).  (When multiple keys are used during encryption, a hash of all the HMAC keys is used to name the file).

If a new key is generated, then subsequent backups will consist of files encrypted with the old key and the new one (since backups are snapshot based, only new/modified files get sent to the backup server and encrypted with the new key).  The `tarcrypt` command handles this gracefully -- the global header contains all the encrypted keys used that are related to the files in the restore set, so the operator will be prompted for the passphrase for each key.  As an ease-of-use operation, if the same passphrase is used on more than one key, it only has to be entered once -- it will automatically be tested against all keys.

You also have the option to force a full backup, which will re-send all files on the client to the backup server, if you don't want to deal with multiple keys, by specifying the `--force-full` parameter (`snebu-client backup --force-full ...`).

=== Other security features

If the `snebu` binary is installed with the suid bit set, then the user that owns it (the `snebu` user in the default case) will own the backup catalog database and the data vault.  Other users on the system can be given access to specific features, restricted to the specified hosts by using the `snebu permissions` subcommand.  For example you can give a user access to back up their host, but not restore.  Or you can restrict their ability to expire backups -- either give permission for a host to only expire their own backups, or restrict expire option to a separate locked down account.  This can be valuable to prevent an attacker from deleting all the backups if a host is compromised.
